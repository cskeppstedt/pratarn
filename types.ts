import Discord from "discord.io";
import winston from "winston";

export interface IStorageMessageView {
  author_id: snowflake;
  author_username: NormalizedUsername;
  channel_id: snowflake;
  content: string;
  id: snowflake;
  timestamp: ISO8601Timestamp;
}

export interface IFetchMessageObjectsResponse {
  count: number;
  messageObjects: IStorageMessageView[];
}

export enum MessageType {
  DEFAULT = 0,
  RECIPIENT_ADD = 1,
  RECIPIENT_REMOVE = 2,
  CALL = 3,
  CHANNEL_NAME_CHANGE = 4,
  CHANNEL_ICON_CHANGE = 5,
  CHANNEL_PINNED_MESSAGE = 6,
  GUILD_MEMBER_JOIN = 7
}

export type snowflake = string;
export type ISO8601Timestamp = string;
export type NormalizedUsername = string;

export interface IUserObject {
  /** snowflake	the user's id	identify */
  id: snowflake;
  /** the user's username, not unique across the platform	identify */
  username: string;
  /** the user's 4-digit discord-tag	identify */
  discriminator: string;
  /** the user's avatar hash	identify */
  avatar?: string;
  /** whether the user belongs to an OAuth2 application	identify */
  bot?: boolean;
  /** whether the user has two factor enabled on their account	identify */
  mfa_enabled?: boolean;
  /** the user's chosen language option	identify */
  locale?: string;
  /** 	whether the email on this account has been verified	email */
  verified?: boolean;
  /** the user's email	email */
  email?: string;
}

export interface IGuildMember {
  /** this users guild nickname (if one is set) */
  nick?: string;
  /** array of snowflakes	array of role object ids */
  roles: [snowflake];
  /** ISO8601 timestamp	when the user joined the guild */
  joined_at: ISO8601Timestamp;
  /** whether the user is deafened */
  deaf: boolean;
  /** whether the user is muted */
  mute: boolean;
}

export interface IMessageObject {
  /** snowflake id of the message */
  id: snowflake;
  /** snowflake	id of the channel the message was sent in */
  channel_id: snowflake;
  /** snowflake id of the guild the message was sent in */
  guild_id?: snowflake;
  /**
   * The author of this message (not guaranteed to be a valid user).
   * The author object follows the structure of the user object, but is only a
   * valid user in the case where the message is generated by a user or bot user.
   * If the message is generated by a webhook, the author object corresponds to
   * the webhook's id, username, and avatar. You can tell if a message is
   * generated by a webhook by checking for the webhook_id on the message object.
   */
  author: IUserObject;
  /** partial guild member object	member properties for this message's author */
  member?: IGuildMember;
  /** contents of the message */
  content: string;
  /** ISO8601 timestamp	when this message was sent */
  timestamp: ISO8601Timestamp;
  /** ISO8601 timestamp	when this message was edited (or null if never) */
  edited_timestamp?: ISO8601Timestamp;
  /** whether this was a TTS message */
  tts: boolean;
  /** whether this message mentions everyone */
  mention_everyone: boolean;
  /** array of user objects, with an additional partial member field	users specifically mentioned in the message */
  mentions: [IUserObject];
  /** array of role object ids	roles specifically mentioned in this message */
  mention_roles: [snowflake];
  /** array of attachment objects	any attached files */
  attachments: [any];
  /** array of embed objects	any embedded content */
  embeds: [any];
  /** array of reaction objects	reactions to the message */
  reactions?: [any];
  /** snowflake	used for validating a message was sent */
  nonce?: snowflake;
  /** whether this message is pinned */
  pinned: boolean;
  /** snowflake	if the message is generated by a webhook, this is the webhook's id */
  webhook_id?: snowflake;
  /** integer	type of message */
  type: MessageType;
  /** message activity object	sent with Rich Presence-related chat embeds */
  activity?: any;
  /** message application object	sent with Rich Presence-related chat embeds */
  application?: any;
}

export interface IMessageEvent {
  d: IMessageObject;
  op: number;
  s: number;
  t: string;
}

export interface IChannelMessage {
  user: string;
  userID: string;
  channelID: string;
  message: string;
  evt: IMessageEvent;
}

export type IHandlerApplicable = (
  bot: Discord.Client,
  logger: winston.Logger,
  channelMessage: IChannelMessage
) => boolean;

export type IHandlerProcess = (
  bot: Discord.Client,
  logger: winston.Logger,
  channelMessage: IChannelMessage
) => void;

export interface IHandler {
  applicable: IHandlerApplicable;
  name: string;
  process: IHandlerProcess;
}
